---
title: 一致性
date: 2021-01-09 13:15:33
tags:
---

## 分布式事务 distributed transaction

对于分布式系统而言，需要保证分布式系统中的数据一致性，保证数据在子系统中始终保持一致，避免业务出现问题。分布式系统中对数要么一起成功，要么一起失败，必须是一个整体性的事务。

分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

简单的说，在分布式系统上一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务节点上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。

举个例子：在电商网站中，用户对商品进行下单，需要在订单表中创建一条订单数据，同时需要在库存表中修改当前商品的剩余库存数量，两步操作一个添加，一个修改，我们一定要保证这两步操作一定同时操作成功或失败，否则业务就会出现问题。

任何事务机制在实现时，都应该考虑事务的 ACID 特性，包括：本地事务、分布式事务。对于分布式事务而言，即使不能都很好的满足，也要考虑支持到什么程度。

典型的分布式事务场景：

1. 跨库事务

跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。

2. 分库分表

通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。

3. 微服务化

微服务架构是目前一个比较一个比较火的概念。例如上面笔者提到的一个案例，某个应用同时操作了 9 个库，这样的应用业务逻辑必然非常复杂，对于开发人员是极大的挑战，应该拆分成不同的独立服务，以简化业务逻辑。拆分后，独立服务之间通过 RPC 框架来进行远程调用，实现彼此的通信。

## 一致性

<!-- More -->

- 一致性 Consistency： 在分布式系统中数据往往存在多个副本，一致性描述的是这些副本中的数据在内容和组织上的一致。

- 可用性 Availability： 描述系统对用户的服务能力，所谓可用是指在用户能够容忍的时间范围内返回用户期望的结果。

- 分区容错性 Partition toleration： 分布式系统通常由多个节点构成，由于网络是不可靠的，所以存在分布式集群中的节点因为网络通信故障导致被孤立成一个个小集群的可能性，即网络分区，分区容错性要求在出现网络分区时系统仍然能够对外提供一致性的可用服务。

### 分类：

- 刚性事务

刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务。

原则：刚性事务满足足 CAP 的 CP 理论

    刚性事务指的是，要使分布式事务，达到像本地式事务一样，具备数据强一致性，从CAP来看，就是说，要达到CP状态。

刚性事务：XA 协议（2PC、JTA、JTS）、3PC，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。

- 柔性事务 Soft State

柔性事务指的是，不要求强一致性，而是要求最终一致性，允许有中间状态，也就是 Base 理论，换句话说，就是 AP 状态。

    与刚性事务相比，柔性事务的特点为：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。

柔性事务分为：

    补偿型
    异步确保型
    最大努力通知型。

柔型事务：TCC/FMT、Saga（状态机模式、Aop 模式）、本地事务消息、消息事务（半消息）

### 一致性

1. 对于关系型数据库我们通常利用事务来保证数据的强一致性
2. 分库分表的策略对数据库实现水平拆分
3. 引入 NoSQL 技术
4. 构建分布式数据库集群

### 数据的强一致性

#### 两阶段提交 --> 两阶段提交 XA

投票：

1. 协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果；
2. 事务参与者收到请求之后，执行事务但不提交，并记录事务日志；
3. 参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。

事务提交：

1. 协调者向各个参与者发送 commit 通知，请求提交事务；
2. 参与者收到事务提交通知之后执行 commit 操作，然后释放占有的资源；
3. 参与者向协调者返回事务 commit 结果信息。

![](https://segmentfault.com/img/bV0KNR)

如果一个或多个参与者回复事务执行失败或者超时的话

1. 协调者向各个参与者发送事务 rollback 通知，请求回滚事务；
2. 参与者收到事务回滚通知之后执行 rollback 操作，然后释放占有的资源；
3. 参与者向协调者返回事务 rollback 结果信息。

问题：

1. 协调者作用巨大，一旦宕机全体就不能用了
2. 执行过程中，堵塞
3. 中间出现网络问题，commit 值达到一部分的 DB，数据还是不能保证一致

--> 超时机制（类比 Redis 集群锁的解锁） 和 互讯机制 （DB 之间互相询问，保证一致性，类比拜占庭问题)

---

#### 三段提交：

1. 预询问：

- 协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复；
- 各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息。

2. 所有的参与者都返回确定信息。接下来和二段提交就一样了

3. 如果不嫌超时或者不确定的信息，

- 协调者向所有事务参与者发送 abort 通知；
- 中断事务

### Soft State

在电商领域等互联网场景下，刚性事务在数据库性能和处理能力上都暴露出了瓶颈。

柔性事务有两个特性：基本可用和柔性状态。

    基本可用是指分布式系统出现故障的时候允许损失一部分的可用性。
    柔性状态是指允许系统存在中间状态，这个中间状态不会影响系统整体的可用性，比如数据库读写分离的主从同步延迟等。柔性事务的一致性指的是最终一致性。

柔性事务主要分为补偿型和通知型，

- 补偿型事务又分：TCC、Saga；

- 通知型事务分：MQ 事务消息、最大努力通知型。

> 补偿型事务都是同步的，通知型事务都是异步的。

#### 通知型事务

通知型事务的主流实现是通过 MQ（消息队列）来通知其他事务参与者自己事务的执行状态，引入 MQ 组件，有效的将事务参与者进行解耦，各参与者都可以异步执行，所以通知型事务又被称为异步事务。

通知型事务主要适用于那些需要异步更新数据，并且对数据的实时性要求较低的场景，主要包含:

    异步确保型事务和最大努力通知事务两种。

- 异步确保型事务：主要适用于内部系统的数据最终一致性保障，因为内部相对比较可控，如订单和购物车、收货与清算、支付与结算等等场景；

- 最大努力通知：主要用于外部系统，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，比如充值平台与运营商、支付对接等等跨网络系统级别对接；

![](https://img-blog.csdnimg.cn/20210709231218519.png)

异步确保型事务

指将一系列同步的事务操作修改为基于消息队列异步执行的操作，来避免分布式事务中同步阻塞带来的数据操作性能的下降。
MQ 事务消息方案

基于 MQ 的事务消息方案主要依靠 MQ 的半消息机制来实现投递消息和参与者自身本地事务的一致性保障。半消息机制实现原理其实借鉴的 2PC 的思路，是二阶段提交的广义拓展。

![](https://img-blog.csdnimg.cn/20210710003838193.png)

1. 事务发起方首先发送半消息到 MQ；
2. MQ 通知发送方消息发送成功；
3. 在发送半消息成功后执行本地事务；
4. 根据本地事务执行结果返回 commit 或者是 rollback；
5. 如果消息是 rollback, MQ 将丢弃该消息不投递；如果是 commit，MQ 将会消息发送给消息订阅方；
6. 订阅方根据消息执行本地事务；
7. 订阅方执行本地事务成功后再从 MQ 中将该消息标记为已消费；
8. 如果执行本地事务过程中，执行端挂掉，或者超时，MQ 服务器端将不停的询问 producer 来获取事务状态；
9. Consumer 端的消费成功机制有 MQ 保证；

#### 扩展阅读 基于阿里 RocketMQ 实现 MQ 异步确保型事务

有一些第三方的 MQ 是支持事务消息的，这些消息队列，支持半消息机制，比如 RocketMQ，ActiveMQ。但是有一些常用的 MQ 也不支持事务消息，比如 RabbitMQ 和 Kafka 都不支持。

以阿里的 RocketMQ 中间件为例，其思路大致为：

1. producer(本例中指 A 系统)发送半消息到 broker，这个半消息不是说消息内容不完整， 它包含完整的消息内容， 在 producer 端和普通消息的发送逻辑一致

2. broker 存储半消息，半消息存储逻辑与普通消息一致，只是属性有所不同，topic 是固定的 RMQ_SYS_TRANS_HALF_TOPIC，queueId 也是固定为 0，这个 tiopic 中的消息对消费者是不可见的，所以里面的消息永远不会被消费。这就保证了在半消息提交成功之前，消费者是消费不到这个半消息的

3. broker 端半消息存储成功并返回后，A 系统执行本地事务，并根据本地事务的执行结果来决定半消息的提交状态为提交或者回滚

4. A 系统发送结束半消息的请求，并带上提交状态(提交 or 回滚)

5. broker 端收到请求后，首先从 RMQ_SYS_TRANS_HALF_TOPIC 的 queue 中查出该消息，设置为完成状态。如果消息状态为提交，则把半消息从 RMQ_SYS_TRANS_HALF_TOPIC 队列中复制到这个消息原始 topic 的 queue 中去(之后这条消息就能被正常消费了)；如果消息状态为回滚，则什么也不做。

6. producer 发送的半消息结束请求是 oneway 的，也就是发送后就不管了，只靠这个是无法保证半消息一定被提交的，rocketMq 提供了一个兜底方案，这个方案叫消息反查机制，Broker 启动时，会启动一个 TransactionalMessageCheckService 任务，该任务会定时从半消息队列中读出所有超时未完成的半消息，针对每条未完成的消息，Broker 会给对应的 Producer 发送一个消息反查请求，根据反查结果来决定这个半消息是需要提交还是回滚，或者后面继续来反查

7. consumer(本例中指 B 系统)消费消息，执行本地数据变更(至于 B 是否能消费成功，消费失败是否重试，这属于正常消息消费需要考虑的问题)

![](https://img-blog.csdnimg.cn/20210710003809243.png)

最大努力通知

最大努力通知方案的目标，就是发起通知方通过一定的机制，最大努力将业务处理结果通知到接收方。

最大努力通知型的最终一致性：

    本质是通过引入定期校验机制实现最终一致性，对业务的侵入性较低，适合于对最终一致性敏感度比较低、业务链路较短的场景。

最大努力通知事务主要用于外部系统，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，比如充值平台与运营商、支付对接、商户通知等等跨平台、跨企业的系统间业务交互场景；

而异步确保型事务主要适用于内部系统的数据最终一致性保障，因为内部相对比较可控，比如订单和购物车、收货与清算、支付与结算等等场景。

MQ 事务消息方案

要实现最大努力通知，可以采用 MQ 的 ACK 机制。

最大努力通知事务在投递之前，跟异步确保型流程都差不多，关键在于投递后的处理。

因为异步确保型在于内部的事务处理，所以 MQ 和系统是直连并且无需严格的权限、安全等方面的思路设计。最大努力通知事务在于第三方系统的对接，所以最大努力通知事务有几个特性：

    业务主动方在完成业务处理后，向业务被动方(第三方系统)发送通知消息，允许存在消息丢失。

    业务主动方提供递增多挡位时间间隔(5min、10min、30min、1h、24h)，用于失败重试调用业务被动方的接口；在通知N次之后就不再通知，报警+记日志+人工介入。

    业务被动方提供幂等的服务接口，防止通知重复消费。

    业务主动方需要有定期校验机制，对业务数据进行兜底；防止业务被动方无法履行责任时进行业务回滚，确保数据最终一致性.

![](https://img-blog.csdnimg.cn/20210710005654223.png)

### 补偿型

但是基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。

这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。这里我们可以引入基于补偿实现的事务，其流程如下：

    创建订单数据，但暂不提交本地事务
    订单服务发送远程调用到现金服务，以扣除对应的金额
    上述步骤成功后提交订单库的事务

以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。

以上流程比基于消息队列实现的事务的流程要复杂，同时开发的工作量也更多：

    编写订单服务里创建订单的逻辑
    编写现金服务里扣钱的逻辑
    编写现金服务里补偿返还的逻辑

可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。
什么是补偿模式？

    补偿模式使用一个额外的协调服务来协调各个需要保证一致性的业务服务，协调服务按顺序调用各个业务微服务，如果某个业务服务调用异常（包括业务异常和技术异常）就取消之前所有已经调用成功的业务服务。

补偿模式大致有 TCC，和 Saga 两种细分的方案

#### TCC 事务模型

什么是 TCC 事务模型

TCC（Try-Confirm-Cancel）的概念来源于 Pat Helland 发表的一篇名为“Life beyond Distributed Transactions:an Apostate’s Opinion”的论文。

TCC 分布式事务模型包括三部分：

1. 主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。

2. 从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作(Try)、确认操作(Confirm)、取消操作(Cancel)三个接口，供主业务服务调用。

在这里插入图片描述

3. 业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。

TCC 提出了一种新的事务模型，基于业务层面的事务定义，锁粒度完全由业务自己控制，目的是解决复杂业务中，跨表跨库等大颗粒度资源锁定的问题。

TCC 把事务运行过程分成 Try、Confirm / Cancel 两个阶段，每个阶段的逻辑由业务代码控制，避免了长事务，可以获取更高的性能。

#### TCC 的工作流程

TCC(Try-Confirm-Cancel)分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器(RM)对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。

TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权。如果主业务服务认为全局事务应该回滚，它会要求取消之前的临时性操作，这就对应从业务服务的取消操作。而当主业务服务认为全局事务应该提交时，它会放弃之前临时性操作的取消权，这对应从业务服务的确认操作。每一个初步操作，最终都会被确认或取消。

因此，针对一个具体的业务服务，TCC 分布式事务模型需要业务系统提供三段业务逻辑：
初步操作 Try：完成所有业务检查，预留必须的业务资源。

确认操作 Confirm：真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次。

取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

在这里插入图片描述
TCC 分布式事务模型包括三部分：

![](https://statics.sdk.cn/articles/img/202012/1bf0b27725f150295091457167_1001046.png?x-oss-process=style/thumb)

Try 阶段： 调用 Try 接口，尝试执行业务，完成所有业务检查，预留业务资源。

Confirm 或 Cancel 阶段： 两者是互斥的，只能进入其中一个，并且都满足幂等性，允许失败重试。

Confirm 操作： 对业务系统做确认提交，确认执行业务操作，不做其他业务检查，只使用 Try 阶段预留的业务资源。
Cancel 操作： 在业务执行错误，需要回滚的状态下执行业务取消，释放预留资源。

Try 阶段失败可以 Cancel，如果 Confirm 和 Cancel 阶段失败了怎么办？

TCC 中会添加事务日志，如果 Confirm 或者 Cancel 阶段出错，则会进行重试，所以这两个阶段需要支持幂等；如果重试失败，则需要人工介入进行恢复和处理等。

#### TCC 事务案例

然而基于补偿的事务形态也并非能实现所有的需求，如以下场景：某笔订单完成时，同时扣掉用户的现金，但交易未完成，也未被取消时，不能让客户看到钱变少了。

这时我们可以引入 TCC，其流程如下：

    订单服务创建订单
    订单服务发送远程调用到现金服务，冻结客户的现金
    提交订单服务数据
    订单服务发送远程调用到现金服务，扣除客户冻结的现金

以上是正常完成的流程，若为异常流程，则需要发送远程调用请求到现金服务，撤销冻结的金额。

以上流程比基于补偿实现的事务的流程要复杂，同时开发的工作量也更多：

    订单服务编写创建订单的逻辑
    现金服务编写冻结现金的逻辑
    现金服务编写扣除现金的逻辑
    现金服务编写解冻现金的逻辑

TCC 实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。
TCC 事务模型的要求：

1. 可查询操作：服务操作具有全局唯一的标识，操作唯一的确定的时间。
2. 幂等操作：重复调用多次产生的业务结果与调用一次产生的结果相同。一是通过业务操作实现幂等性，二是系统缓存所有请求与处理的结果，最后是检测到重复请求之后，自动返回之前的处理结果。
3. TCC 操作：Try 阶段，尝试执行业务，完成所有业务的检查，实现一致性；预留必须的业务资源，实现准隔离性。Confirm 阶段：真正的去执行业务，不做任何检查，仅适用 Try 阶段预留的业务资源，Confirm 操作还要满足幂等性。Cancel 阶段：取消执行业务，释放 Try 阶段预留的业务资源，Cancel 操作要满足幂等性。TCC 与 2PC(两阶段提交)协议的区别：TCC 位于业务服务层而不是资源层，TCC 没有单独准备阶段，Try 操作兼备资源操作与准备的能力，TCC 中 Try 操作可以灵活的选择业务资源，锁定粒度。TCC 的开发成本比 2PC 高。实际上 TCC 也属于两阶段操作，但是 TCC 不等同于 2PC 操作。
4. 可补偿操作：Do 阶段：真正的执行业务处理，业务处理结果外部可见。Compensate 阶段：抵消或者部分撤销正向业务操作的业务结果，补偿操作满足幂等性。约束：补偿操作在业务上可行，由于业务执行结果未隔离或者补偿不完整带来的风险与成本可控。实际上，TCC 的 Confirm 和 Cancel 操作可以看做是补偿操作。

TCC 的使用场景

TCC 是可以解决部分场景下的分布式事务的，但是，它的一个问题在于，需要每个参与者都分别实现 Try，Confirm 和 Cancel 接口及逻辑，这对于业务的侵入性是巨大的。

TCC 方案严重依赖回滚和补偿代码，最终的结果是：回滚代码逻辑复杂，业务代码很难维护。所以，TCC 方案的使用场景较少，但是也有使用的场景。

比如说跟钱打交道的，支付、交易相关的场景，大家会用 TCC 方案，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。

在这里插入图片描述

![](https://img-blog.csdnimg.cn/20201102225620490.jpg)

总体的方案对比：
| 属性 | 2PC | TCC | Saga | 异步确保型事务 | 尽最大努力通知 |
|----------|--------|--------|---------|------------|------------|
| 事务一致性 | 强 | 弱 | 弱 | 弱 | 弱 |
| 复杂性 | 中 | 高 | 中 | 低 | 低 |
| 业务侵入性 | 小 | 大 | 小 | 中 | 中 |
| 使用局限性 | 大 | 大 | 中 | 小 | 中 |
| 性能 | 低 | 中 | 高 | 高 | 高 |
| 维护成本 | 低 | 高 | 中 | 低 | 中 |
