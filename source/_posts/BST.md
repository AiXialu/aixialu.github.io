## Binary Tree

### 二叉树

1. 二叉树第 i 层至多有 2^（i-1）个结点（i>=1）。
2. 深度为 k 的二叉树上，至多含 2^k-1 个结点（k>=1）
3. n0 = n2 + 1（度）
4. 满二叉树：深度为 k 且含有 2^k-1 个结点的树。
5. 完全二叉树：除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。
   （树中所含 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应）。
6. 具有 n 个结点的完全二叉树的深度为[log2n] + 1。
7. 二叉树的链式存储表示：二叉链表、三叉链表（增加双亲指针域）、双亲链表、 线索链表。
8. 二叉树的遍历：前、中、后。
9. 二叉树的遍历算法：递归、非递归（栈：现在经过不访问，一会访问的结点入栈，栈空结束遍历）。
10. 二叉树递归遍历引申的算法：求树的深度、结点个数、复制二叉树等。
11. 二叉树相关算法一定要考虑空树的情况。
12. 表达式和二叉树的关系： [第一操作数][二元运算符][第二操作数] = [左节点][双亲结点][右结点]，（先中后）缀对应（前中后）遍历。
13. 线索二叉树：二叉链表中增加两个标志域，让左右两个指针增加功能：有子结点则指向子结点，没有则指向前驱和后继（某种遍历方式）。
14. 树和二叉树的相互转换，树的叶子结点：左子树空。树、森林与二叉树的转换
15. 遍历二叉树的所有叶子节点。
16. 树的存储结构
17. 哈夫曼树
18. 平衡二叉树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。

### 具体知识

#### 二叉树（Binary tree）

每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。在这里插入图片描述

![](https://img-blog.csdnimg.cn/54bfef48d9be460c99d69445387cf3d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB5a2m5Lmg55qE6Zi_6I2j,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 满二叉树 Full Binary Tree

一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。假设二叉树的层数为 k

- 满二叉树的结点总和：2k - 1
- 每一层最多的结点个数：2k-1

  ![](https://img-blog.csdnimg.cn/fc940177758346a08fce16fc2224612a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB5a2m5Lmg55qE6Zi_6I2j,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 完全二叉树 Complete Binary Tree

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。假设二叉树的层数为 k

完全二叉树最底层的结点个数范围为：1 ~ 2k-1-1

![](https://img-blog.csdnimg.cn/620272cae418482e9ebd0fbf3214395e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB5a2m5Lmg55qE6Zi_6I2j,size_20,color_FFFFFF,t_70,g_se,x_16)

#### Binary Search Tree

有数值，且是一个有序树。

若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉排序树

#### Self-balancing binary search tree

可以是一棵空树
如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。

![](https://img-blog.csdnimg.cn/646387adc1a64093ac2000fa24160696.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB5a2m5Lmg55qE6Zi_6I2j,size_20,color_FFFFFF,t_70,g_se,x_16)

---

### 注意点

> 平衡二叉搜索树（AVL 树）是不是二叉搜索树和平衡二叉树的结合？

是的，是二叉搜索树和平衡二叉树的结合。

> 平衡二叉树与完全二叉树的区别在于底层节点的位置？

是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。
且平衡二叉树有序，存在数值，完全二叉树可以没有数值。

> 堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？

堆近似的可以看作完全二叉树，同时保证父子节点的顺序关系（有序）。
堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树

---

#### 前，中，后续遍历中的序

所谓前序，中序，后续遍历命名的由来是我们访问二叉树，根节点的顺序。前序遍历就是优先访问根节点，中序遍历是第二个访问根节点，后续遍历就是访问完左右节点之后，最后访问根节点。注意访问二字。访问和获取是两个不同的概念，我们可以获取一个节点，但是不访问他。对应在计算机里的概念是，获取一个节点表示将他入栈，访问一个节点是他处于栈顶，我们即将让他出栈。

> 前序遍历

![](https://pic4.zhimg.com/80/v2-68e58c53aac2e57a5be584323dc6863b_720w.webp)

遍历顺序:根节点->左节点->右节点

遍历结果:4->2->1->3->6->5->7

可能有些小伙伴会有疑惑为什么在前序遍历结果是 4->2->1，而不是 4-2-6。你不是说前序遍历的顺序不是根节点->左节点->右节点。2 遍历了，应该遍历 6 啊。
如果你有这样的疑问，那是因为你混淆了深度优先和广度优先的概念了。4-2-6 是遍历了第一层 4，然后接着遍历了 4 的下一层 2，6。这明显是一个广度优先的遍历结果。那什么是深度优先呢？用幼儿园的话来说，你要向前走而不是向左右走。和深度遍历相结合的数据结构是栈，这是一个具有后入先出特性的数据结构，当你从 4 遍历到左节点 2 之后，4 和 2 都已经入栈了，而 2 是栈顶的元素，根据栈后入先出的原理，计算机会先处理 2 这个节点而不是 4，所以 2 成为了新的根节点。那么我们输出 4-2 之后谁是 2 的左节点，明显是 1，而不会是 6 啊。所以是这里是一个 4-2-1 的顺序。

> 中序遍历

遍历顺序:左节点->根节点->右节点
![](https://pic3.zhimg.com/80/v2-7837ea43bb0b811a0a05a249f47be506_720w.webp)
遍历结果:1->2->3->4->5->6->7

> 后序遍历

![](https://pic4.zhimg.com/80/v2-8a9373010aca8f2eb970c66568c885ab_720w.webp)

遍历顺序:左节点->右节点->根节点
遍历结果：1->3->2->5->7->6->4
你可以按照中序遍历的方法，根据左，右，中的顺序。自己尝试手动输出后续遍历的结果。

---

### 经典题

1. 表达式和二叉树的关系： [第一操作数][二元运算符][第二操作数] = [左节点][双亲结点][右结点]，（先中后）缀对应（前中后）遍历。

https://willendless.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2021/01/11/%E5%89%8D%E5%90%8E%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/

https://leetcode.com/problems/basic-calculator/
https://leetcode.com/problems/basic-calculator-ii/
https://leetcode.com/problems/basic-calculator-iii/

2. 线索二叉树

二叉链表中增加两个标志域，让左右两个指针增加功能：有子结点则指向子结点，没有则指向前驱和后继（某种遍历方式）。

3. 树和二叉树的相互转换，树的叶子结点：左子树空。树、森林与二叉树的转换

4. 遍历二叉树的所有叶子节点

5. 数的三种表示方法

树的存储结构
对于存储结构，可能会联想到前面的顺序存储和链式存储结构。但是对于数这种可能会有很多孩子的特殊数据结构，只用顺序存储结构或者链式存储结构很那实现，那么可以将这两者结合，产生主要的三种存储结构表示法：双亲表示法、孩子表示法、孩子兄弟表示法。

> 双亲表示法

双亲表示法定义
假设以一组连续空间存储数的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。

双亲表示的结点结构

| data(数据域)       | parent(指针域)                   |
| ------------------ | -------------------------------- |
| 存储结点的数据信息 | 存储该结点的双亲所在数组中的下标 |

代码实现双亲表示法

```
/* 树的双亲表法结点结构定义*/
#define MAX_TREE_SIZE 100
typedef int  ElemeType;

typedef struct PTNode{ // 结点结构
    ElemeType data; //结点数据
    int parent;    // 双亲位置
}PTNode;

typedef struct { // 树结构
    PTNode nodes[MAX_TREE_SIZE];   // 结点数组
    int r; // 根的位置
    int n; // 结点数
}PTree;
```

双亲表示法的特点
由于根结点是没有双亲的，约定根结点的位置位置域为-1.
根据结点的 parent 指针很容易找到它的双亲结点。所用时间复杂度为 O(1)，直到 parent 为-1 时，表示找到了树结点的根。
缺点：如果要找到孩子结点，需要遍历整个结构才行。

> 孩子表示法

把每个结点的孩子结点排列起来，以单链表作为存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

孩子链表的孩子结点

| child(数据域)                  | next(指针域)                         |
| ------------------------------ | ------------------------------------ |
| 存储某个结点在表头数组中的下标 | 存储指向某结点的下一个孩子结点的指针 |

表头数组的表头结点

| data(数据域)           | firstchild(头指针域)         |
| ---------------------- | ---------------------------- |
| 存储某个结点的数据信息 | 存储该结点的孩子链表的头指针 |

代码实现孩子表示法

```
/* 树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef int  ElemeType;

typedef struct CTNode{  // 孩子结点
    int child; // 孩子结点的下标
    struct CTNode * next; // 指向下一结点的指针
}*ChildPtr;

typedef struct {  // 表头结构
    ElemeType data; // 存放在数中的结点数据
    ChildPtr firstchild; // 指向第一个孩子的指针
}CTBox;

typedef struct {  // 树结构
    CTBox nodes[MAX_TREE_SIZE]; // 结点数组
    int r;  // 根的位置
    int n;  // 结点树
}CTree;
```

> 双亲孩子表示法定义

对于孩子表示法，查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。但是当要寻找某个结点的双亲时，就不是那么方便了。所以可以将双亲表示法和孩子表示法结合，形成双亲孩子表示法。

show code

```
/* 树的双亲孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef int  ElemeType;

typedef struct CTNode{  // 孩子结点
    int child;  // 孩子结点的下标
    struct CTNode * next;  // 指向下一结点的指针
}*ChildPtr;

typedef struct {  // 表头结构
    ElemeType data;  // 存放在数中的结点数据
    int parent;      // 存放双亲的下标
    ChildPtr firstchild;  // 指向第一个孩子的指针
}CTBox;

typedef struct {  // 树结构
    CTBox nodes[MAX_TREE_SIZE]; // 结点数组
    int r;  // 根的位置
    int n;  // 结点树
}CTree;
```

> 孩子兄弟表示法

孩子兄弟表示法定义
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

孩子兄弟表示法的结点结构

| data(数据域)       | firstchild(指针域)               | rightsib(指针域)                 |
| ------------------ | -------------------------------- | -------------------------------- |
| 存储结点的数据信息 | 存储该结点的第一个孩子的存储地址 | 存储该结点的右兄弟结点的存储地址 |

代码实现孩子兄弟表示法

```
/* 树的孩子兄弟表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef int  ElemeType;

typedef struct CSNode{
    ElemeType data;
    struct CSNode * firstchild;
    struct CSNode * rightsib;

}CSNode, *CSTree;
```

> 哈夫曼树

https://leetcode.com/problems/minimum-cost-to-connect-sticks/description/

1. 给定 n 个权值作为 n 的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。
2. 哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
3. 构造
   1. 权值最小的两个结点，构造成一棵二叉树，该二叉树的权值为两个结点之和，并把该二叉树看成结点。
   2. 重复 1 步骤。
   3. 哈夫曼编码：字符出现次数等同于权值，是变长编码。
   4. 可以使用哈夫曼编码进行压缩文件。
   5. 哈夫曼树只是一棵最优二叉树,不一定是完全二叉树,也不一定是平衡二叉树。
   6. 哈夫曼树每个结点要么没有子节点，要么有两个子节点，可考虑哈夫曼树的构成。
