---
title: Java-multi-thread
date: 2020-12-24 01:42:49
tags:
---

## Thread in Java

### 用户线程和守护线程有什么区别？
当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。

### 我们如何创建一个线程？
有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在Java中创建线程的文章。

### 有哪些不同的线程生命周期？
当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。

![](https://cdn.journaldev.com/wp-content/uploads/2012/12/Thread-Lifecycle-States-450x227.png)

### 你对线程优先级的理解是什么？
每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。

### 线程调度

1. 先进先出算法（FIFO，First-In-First-Out）

按照任务进入队列的顺序，依次调用，执行完一个任务再执行下一个任务，只有当任务结束后才会发生切换。

优点：

最少的任务切换开销（因为没有在任务执行过程中发生切换，故任务切换开销为0）
最大的吞吐量（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的）
最朴实的公平性（先来先做）
缺点：

平均响应时间高：耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度了。

适用场景：队列中任务的耗时差不多的场景。

2. 最短耗时任务优先算法（Shortest Job First， SJF）

按照任务的耗时长短进行调度，优先调度耗时短的任务，这个算法有个前提，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。另外，这个时间是指任务剩余还需要的执行时间，举例，一个耗时1小时的任务还剩10秒执行完成，这个时候若再来一个耗时1分钟的任务，调度仍然还是继续执行完那个耗时1小时的任务，因为他剩余的时间是10秒，比1分钟短，所以此算法又叫最短剩余时间任务有限算法（SRTJ），能够解决FIFO算法中短耗时任务等待前面耗时长任务的窘境。

优点：

平均响应时间较低：这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。
缺点：

耗时长的任务迟迟得不到调度，不公平，容易形成饥饿
频繁的任务切换，调度的额外开销大

3. 时间片轮转算法（Round Robin）

给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，这样能解决SJF中耗时长任务饥饿的问题。算法介于FIFO和SJF之间，若时间片足够大，则退化到FIFO，若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列（相比SFJ，任务执行的绝对时间会长，取决于队列中任务的个数）。

优点：

每个任务都能够得到公平的调度
耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行
缺点：

任务切换引起的调度开销较大，需要多次切换任务上下文（特别是CPU的Cache，多次切换容易导致Cache完全不命中，需要重新从内存加载，这个非常耗时）
时间片不太好设置（若设置短了，调度开销大，若设置长了，极端情况是退化到FIFO）

适用场景：队列中耗时差不多的任务（比如，多路视频流处理）

不适用场景：计算型任务和I/O型任务混合的队列

4. 最大最小公平算法（ Max-Min Fairness ）（类比网络的Max-Min模型)

5. Multi-level Feedback Queue（MFQ)

- 有多个Level，从上到下，优先级越来越低，分片时长越来越大。
- 位于高优先级Level的任务可以抢占低优先级Level的任务。
- 新任务首先位于高优先级Level，当一个时间片用完之后，若任务结束，则正常退出系统，若任务还没有结束，则下滑到低一等级的Level。若是因等待I/O而主动让出CPU处理，则停留在当前Level（或者提高一个Level）。
- 同一Level的任务采用Round Robin算法。
- 为避免系统中有太多的I/O任务而导致计算型任务迟迟得不到处理，MFQ算法会监控每个任务的处理耗时、确保其拥有公平的资源分配（按照最大最小公平算法）。在每个Level的所有任务，若有任务还没有用完分配给他的资源，则相应提高他的优先级，反之则降低其优先级。

6. 优先级：

- 记住当线程的优先级没有指定时，所有线程都携带普通优先级。
- 优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。
- 记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。
- 与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。
- 由调度程序决定哪一个线程被执行。
- t.setPriority()用来设定线程的优先级。
- 记住在线程开始方法被调用之前，线程的优先级应该被设定。
- 你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级

6. Yield VS Join（调度方法）

- Yield： yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置，一般上在结束之后会进行线程切换

    - Yield告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。
    - Yield不能保证使得当前正在运行的线程迅速转换到可运行的状态
    - 它仅能使一个线程从运行状态转到可运行状态，而不是等待或阻塞状态

- JOIN:使得一个线程在另一个线程结束后再执行, 如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。(Main等在Thread结束之后在结束

7. Wait VS Notify VS NotifyAll

- wait: 

    - 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 
    如前面所述，wait以及notify以及notifyAll都需要持有监视器才可以调用该方法
    既然另外两个版本都是依赖底层的这个wait，所以所有版本的wait都需要持有监视器
    - 一旦该方法调用，将会进入该监视器的等待集，并且放弃同步要求（也就是不再持有锁，将会释放锁）
    - 一定注意：将会释放锁，将会释放锁，会释放锁......

    ![](https://img2018.cnblogs.com/blog/897393/201903/897393-20190304090303565-566951789.png)

    遇到这几种情况后，将会从对象的等待集中删除线程，并重新进行线程调度

- Notify: 随机唤醒一个wait状态的线程
- NotifyAll：唤醒全部的wait线程

---> 线程通信

--- 

8. Volatile:

当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。

9. 守护进程：

系统性进程，不是user创建的，比如说HTTPD， SSHD

10. 什么是Callable和Future?

Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。

Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。

11. 什么是线程死锁，

    产生死锁的条件有四个：
    
        
        互斥条件：所谓互斥就是进程在某一时间内独占资源。 
        
        
        请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
        
        
        不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 
        
        
        循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

12. Volatile Synchronized

Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。

volatile可以保证可见性和顺序性， 但是不能保证原子性

原因：

Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。

举个栗子

一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。
线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。

问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。


