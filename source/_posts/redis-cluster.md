---
title: redis-cluster
date: 2020-10-28 15:09:12
tags:
---

## Redis 集群

### 故障检测与修复

#### 故障恢复总体介绍

Master-Slave:

1. 下线Master节点的Slave节点来成为新的Master节点，接管旧Master负责的所有slots向外提供服务
2. 当集群中的某个Master节点没有Slave节点时（称之为 Orphaned Master），其他有富余Slave节点的主节点会向该节点迁移一个Slave节点以防该节点下线之后没有子节点来替换从而导致整个集群下线(Replica Migration)

- 故障发现： PFAIL -- FAIL

    PFAIL就是主观下线，比如节点1判定节点3下线，那么他会标记节点3的状态为PFAIL。但是如果绝大部分节点都判定节点3为PFAIL，那么我们就可以断定节点3故障下线，其状态判定为FAIL状态

    Redis的每个节点会不停的向其他节点发送PING消息来与其他节点同步信息的同时检测其他节点是否可达
    1. Ping不同 --》 重新连接
    2. 连接超时 --》 PFAIL
    3. 然后向其他随机节点发送PFAIL 信息，然后收到信息的节点在进行判断
    4. 当超过一半的节点 发现PFAIL的时候， -》 FAIL 并且广播出去

- 故障迁移

1. 资格检查

    Slave节点会不停的与Master节点通信来复制Master节点的数据，如果一个Slave节点长时间不与Master节点通信，那么很可能意味着该Slave节点上的数据已经落后Master节点过多（因为Master节点再不停的更新数据但是Slave节点并没有随之更新）

2. 休眠：Raft

    所有参与选举的节点首先随机休眠一段时间，每个节点一旦唤醒就立刻向所有的投票节点发起拉票请求。对于投票节点来说，每一轮选举中只能投出一票，投票的规则就是先到先得。所以一般情况下，都是休眠时间最短的节点容易获得大部分投票

    - 一部分为固定的500ms时间，这500ms主要是为了等待集群状态同步。上面我们讲到节点2会向集群所有节点广播消息，那么这500ms就是等待确保集群的所有节点都收到了消息并更新了状态。
        
    - 另一部分主要是一个随机的时间加上由该Slave节点的排名决定的附加时间。我们在之前主从复制的文章中讲过，每个slave都会记录自己从主节点同步数据的复制偏移量。复制偏移量越大，说明该节点与主节点数据保持的越一致。那么显然我们选举的时候肯定是想选状态更新最近的子节点，所以我们按照更新状态的排序来确定休眠时间的附加部分。状态更新最近的节点SLAVE_RANK排名为1，那么其休眠的时间相应的也最短，也就意味着该节点最有可能获得大部分选票。

3. 发起拉票&选举投票

    主节点才能投票

4. 替换节点

    S1替换节点3的过程比较清晰易懂。即首先标记自己为主节点，然后将原来由节点3负责的slots标记为由自己负责，最后向整个集群广播现在自己是Master同时负责旧Master所有slots的信息。其他节点接收到该信息后会更新自己维护的S1的状态并标记S1为主节点，将节点3负责的slots的负责节点设置为S1节点。

5. 集群配置更新

    那么最后我们需要解决的是，当S1成为了新的Master之后，S2和节点3该如何处理？显然并不是篡位之后就杀掉hh。实际上我们是让S2和节点3成为新的主节点S1的Slave节点，去备份S1节点的数据。那这个过程是如何进行的呢？这是在各个节点信息更新的时候自动实现的。当节点3故障恢复重新上线后，发现原先本该由自己负责的slot被S1负责了，那么他就知道自己被替代了，会自动成为S1节点的子节点，当S2节点发现原先应该由其Master节点3负责的slot被S1负责了，那么他就知道自己的Master被替代了，就会成为S1的Slave节点。

