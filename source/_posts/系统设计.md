---
title: 系统设计
date: 2021-01-11 14:01:22
tags:
---

### 系统设计

终于到了系统设计：

考察点：

- 思维是否开阔、灵活
- 知识广度
- 知识深度
- 架构能力是否足够，是否能设计出可扩展的系统
- 是否能熟练使用常见工具并且知晓特性，能够因地制宜选择合适的方案和工具

明确问题

1. QPS
2. 峰值
3. 永久保存 --> Redis / MySQL
4. 内存

常见的性能指标

- Nginx：能轻松的处理c100k问题，内存越大，能处理的并发量越高
- Redis: https://redis.io/topics/benchmarks 表明，对于GET/SET来说，QPS 10-100k没啥大问题
- MySQL: https://www.mysql.com/why-mysql/benchmarks/ 表明，对于只读，QPS 几百k没啥问题，对于写，MySQL 5.7 QPS 100k 几乎是上限

常见知识

- 最简单粗暴也是实践中最常用的应对方案就是：升级机器、加机器(所以架构的时候要考虑好水平扩展)
- 大多数应用都是读大于写，解决方案很简单：加缓存+读写分离
- 对于写大于读的方案  --> 垂直分表 (一张大表的n列重新组合，把一些不必要的列拆出去，组成新的表) + 水平分表(水平分表是指将表按照某个维度切割成多个表，例如时间。例如有些消息系统可能只需要保存三个月的数据，那么可以把 三个月以前的数据插入到另外一张表中。这样做能优化性能的主要原因是减少了表的行数，从而降低B树的深度或子节点数量， 减少数据量，减少I/O，提高查询速度)
- 需要长时间处理的任务或者是强依赖网络(而网络不确定性大的问题)，妥妥的用队列，例如消息推送
- 性能优化套路：加机器 - 加缓存 - 优化数据库索引 - 垂直拆数据库表 - 水平拆数据库表 - 垂直分库 - 水平分库

### 练习题： 全局唯一ID

- 全局唯一：必须保证ID是全局性唯一的，基本要求
- 高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈
- 高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性
- 好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单
- 趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求

1. UUID

优点：
- 生成足够简单，本地生成无网络消耗，具有唯一性
缺点：

- 无序的字符串，不具备趋势自增特性
- 没有具体的业务含义
- 长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。

2. 数据库自增ID (集群也是一样的，集群的话 还不能保证stride是一样的)

--> DB单点存在宕机风险，无法扛住高并发场景

3. Redis模式(给予数据库的优化)

```
127.0.0.1:6379> set seq_id 1     // 初始化自增ID为1
OK
127.0.0.1:6379> incr seq_id      // 增加1，并返回递增后的数值
(integer) 2
```

问题： 用redis实现需要注意一点，要考虑到redis持久化的问题

- RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。
- AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。

4. Snowflake（Twitter）([Go](https://github.com/bwmarrin/snowflake))

Snowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。

Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。

第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。

时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年

工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。

序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID

根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。

![](https://pic2.zhimg.com/80/v2-4f51c7b6704323cc376b5a8a9a7cad09_720w.jpg)

---

### 短链服务：

-- 发号策略，给每一个过来的长地址，发一个号即可，

>小型系统直接用mysql的自增索引就搞定了。

>如果是大型应用，可以考虑各种分布式key-value系统做发号器。不停的自增就行了。第一个使用这个服务的人得到的短地址是http://xx.xx/0 第二个是 http://xx.xx/1 第11个是 http://xx.xx/a 第依次往后，相当于实现了一个62进制的自增字段即可。

拓展：

1. 62进制如何用数据库或者KV存储来做？

其实我们并不需要在存储中用62进制，用10进制就好了。比如第10000个长地址，我们给它的短地址对应的编号是9999，我们通过存储自增拿到9999后，再做一个10进制到62进制的转换，转成62进制数即可。这个10～62进制转换，你完全都可以自己实现。

2. 如何保证发号器的大并发高可用

上面设计看起来有一个单点，那就是发号器。如果做成分布式的，那么多节点要保持同步加1，多点同时写入，这个嘛，以CAP理论看，是不可能真正做到的。其实这个问题的解决非常简单，我们可以退一步考虑，我们是否可以实现两个发号器，一个发单号，一个发双号，这样就变单点为多点了？依次类推，我们可以实现1000个逻辑发号器，分别发尾号为0到999的号。每发一个号，每个发号器加1000，而不是加1。这些发号器独立工作，互不干扰即可。而且在实现上，也可以先是逻辑的，真的压力变大了，再拆分成独立的物理机器单元。1000个节点，估计对人类来说应该够用了。如果你真的还想更多，理论上也是可以的。

3. 具体存储如何选择 

DB Redis 一致性的问题：

- 先更新数据库，再更新缓存(普通低并发)
- 直接操作缓存，定期写入sql(适合高并发)

4. 长地址多次转换，出来还是同一个短地址

最简单的是建立一个长对短的hashtable，这样相当于用空间来换空间，同时换取一个设计上的优雅

用key-value存储，保存“最近”生成的长对短的一个对应关系。注意是“最近”，也就是说，我并不保存全量的长对短的关系，而只保存最近的。比如采用一小时过期的机制来实现LRU淘汰。这样的话，长转短的流程变成这样：

1 在这个“最近”表中查看一下，看长地址有没有对应的短地址

1.1 有就直接返回，并且将这个key-value对的过期时间再延长成一小时

1.2 如果没有，就通过发号器生成一个短地址，并且将这个“最近”表中，过期时间为1小时所以当一个地址被频繁使用，那么它会一直在这个key-value表中，总能返回当初生成那个短地址，不会出现重复的问题。如果它使用并不频繁，那么长对短的key会过期，LRU机制自动就会淘汰掉它。

---

重点：

>Scenario（场景），Service（服务），Storage（存储），Scale（扩展）